root Trie will NOT be placed in ARRAY; every other node will

# NAP == number of appearances only after it’s given a code
# codes printed out == # codes inserted (assuming table isn’t full yet)
# codes printed out <  # codes
BUG: without -e, misses the newline (need to print last char)
BUG: with -e, i print out single-chars twice if next char is also unknown
 	-instead of building on unknown chars, just insert them and 
	


BUG: infinite loop on -e new single chars when codes can’t be assigned


Check if pruning works for -e case

Find natural algorithm for -e case… setting C = (EMPTY, K) might not be optimal.
what if you can’t assign a code to a new single-char?

-e: special codes for new characters
	0 (in however many nBits) special char followed by  8bit
 
initializing table with all 1-char strings?
	set int to 0-255? no

code.c is for sending (encode) and receiving (decode)


why getchar() returns int:
	needs a way to signal special character (e.g. EOF)
—
Questions to ponder:
-new assignment of codes after prunes has to be same in encode (new trie) and decode (new array)
	-use combined array/trie structure

array has pointers to nodes
nodes have codes===indices of array
when adding string to trie, put new pointer in array to that node
pruning trie:
	find root of subtrie that needs to be pruned
	recursively free/set array pointer to NULL
	make new array by putting non-NULL pointers in contiguously
	(if you want to keep the 1-char strings, check trie depth)
——
Compression algo with trie methods:

Trie t = top of the trie

C = t
While ((K = getchar()) != EOF)
	Trie currT = getT(C,K);
	if (currT != NULL && hasCode(currT))
		
		C = currT
	else
		putBit(getCode(C))